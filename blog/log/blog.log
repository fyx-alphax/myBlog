2021-05-04 10:59:13.245  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : Starting BlogApplication using Java 12.0.2 on LAPTOP-B2BM54RN with PID 15436 (E:\IdeaProjects\blog\target\classes started by 轩 in E:\IdeaProjects\blog)
2021-05-04 10:59:13.253 DEBUG 15436 --- [restartedMain] com.program.blog.BlogApplication         : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 10:59:13.253  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : The following profiles are active: dev
2021-05-04 10:59:13.369  INFO 15436 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2021-05-04 10:59:13.370  INFO 15436 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2021-05-04 10:59:17.202  INFO 15436 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-05-04 10:59:17.241  INFO 15436 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-05-04 10:59:17.241  INFO 15436 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-05-04 10:59:17.417  INFO 15436 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-05-04 10:59:17.418  INFO 15436 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 4047 ms
2021-05-04 10:59:18.665  INFO 15436 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 10:59:18.863  INFO 15436 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 10:59:20.608  INFO 15436 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-05-04 10:59:20.779  INFO 15436 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-05-04 10:59:20.816  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : Started BlogApplication in 8.898 seconds (JVM running for 11.592)
2021-05-04 10:59:30.443  INFO 15436 --- [http-nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet 'dispatcherServlet'
2021-05-04 10:59:30.443  INFO 15436 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet 'dispatcherServlet'
2021-05-04 10:59:30.445  INFO 15436 --- [http-nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms
2021-05-04 10:59:30.472  INFO 15436 --- [http-nio-8080-exec-1] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.LoginController.loginPage, args=[])
2021-05-04 10:59:30.478  INFO 15436 --- [http-nio-8080-exec-1] com.program.blog.aspect.LogAspect        : Result : admin/login
2021-05-04 10:59:35.113  WARN 15436 --- [http-nio-8080-exec-7] o.a.c.util.SessionIdGeneratorBase        : Creation of SecureRandom instance for session ID generation using [SHA1PRNG] took [611] milliseconds.
2021-05-04 10:59:35.119  INFO 15436 --- [http-nio-8080-exec-7] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/login, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.LoginController.login, args=[fyx, fyx, org.apache.catalina.session.StandardSessionFacade@20a488ba, {}])
2021-05-04 10:59:35.153  INFO 15436 --- [http-nio-8080-exec-7] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2021-05-04 10:59:36.975  INFO 15436 --- [http-nio-8080-exec-7] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2021-05-04 10:59:37.269  INFO 15436 --- [http-nio-8080-exec-7] com.program.blog.aspect.LogAspect        : Result : admin/index
2021-05-04 10:59:38.989  INFO 15436 --- [http-nio-8080-exec-2] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs;jsessionid=E734B7492B14A8FE5277D9EC85335E01, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogsPage, args=[{}, 1])
2021-05-04 10:59:39.300  INFO 15436 --- [http-nio-8080-exec-2] com.program.blog.aspect.LogAspect        : Result : admin/blogs
2021-05-04 10:59:41.408  INFO 15436 --- [http-nio-8080-exec-5] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs/1/edit, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogEditPage, args=[1, {}])
2021-05-04 10:59:41.541  INFO 15436 --- [http-nio-8080-exec-5] com.program.blog.aspect.LogAspect        : Result : /admin/blogs-input
2021-05-04 11:05:01.368  INFO 15436 --- [http-nio-8080-exec-3] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs/1/edit, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogEdit, args=[1, Blog(id=1, title=Web学习——过滤器, content=# Web学习

## 过滤器

### Filter

功能：

1、用来拦截传入的请求和传出的响应。

2、修改或以某种方式处理正在客户端和服务端之间交换的数据流。

使用方式：

与使用 Servlet 类似，Filter 是 Java web 提供的一个接口，开发者只需要自定义一个类并实现该接口即可。

``` Java
package com.example.filter;

import javax.servlet.*;
import java.io.IOException;

public class CharacterFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("UTF-8");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}

```

1、Filter 接口有三个函数，另外两个函数有 default 关键字修饰，可实现可不实现。

2、在 doFilter 中，拦截的 request 经过业务处理后通过 filterChain 将处理后的 request 或 response 传递给相应的 servlet，否则，请求/响应就会一直停留在过滤器中。(filterChain.doFilter(servletRequest, servletResponse);)

配置 web.xml

~~~ xml
	<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
        <url-pattern></url-pattern>
    </filter-mapping>
~~~

通过以上方式配置拦截器映射，要是相同拦截方式的界面有多个，可以添加多个 url-pattern。

### Filter生命周期

当 Tomcat 启动时，同过反射机制调用 Filter 的无参构造函数创建实例化对象，同时调用 init 方法完成初始化，一次请求时调用一次 doFilter ，多次请求 ，doFilter 方法就调用多次，当 Tomcat 服务器关闭时，调用 destory 方法销毁 Filter 对象。

无参构造函数：只调用一次，当 Tomcat 启动时调用（Filter 一定要在 web.xml 中配置）

init 函数：只调用一次，当 Filter 实例化对象创建完成之后调用。

doFilter 函数：调用多次，访问 Filter 的业务逻辑都写在 Filter 中。

destory 函数：调用一次，当 Tomcat 关闭时调用。



同时配置多个 Filter 时，Filter 的调用顺序是由 web.xml 中的配置顺序决定的，写在上面的先调用，因为 web.xml 是从上到下读取的。

~~~ xml
<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

    <filter>
        <filter-name>my</filter-name>
        <filter-class>com.example.filter.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>my</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

~~~



也可以通过注解的方式配置 Filter 

~~~ java
@WebFilter("/test")
public class CharacterFilter implements Filter {
    
}
~~~



### Filter 的使用场景

1、解决中文乱码问题。

2、屏蔽敏感词。

​		获取从浏览器传递的信息通过 Parameter 获取，两个资源之间信息的传递通过 Attribute

3、控制资源的访问权限。

~~~ Java
package com.example.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
@WebFilter("/download.jsp")
public class DownloadFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();
        String name = (String)session.getAttribute("name");
        if (name == null) {
            response.sendRedirect("/login.jsp");
        } else {
            filterChain.doFilter(request, response);
        }
    }
}

~~~





## 文件上传和下载

- JSP

1、input 的 type 设置为 file。

2、form 表单的 method 必须设置为 post，如果是 get 只会上传文件名而不是文件。

3、form 表单的 enctype 设置 multipart/form-data，以二进制的形式传输数据。

- Servlet

在实际开发中，使用 fileupload 组件上传文件，属于第三方组件，需要下载 jar 包。可以将所有的请求信息都解析成 Fileitem 对象，通过对 Fileitem 对象的操作完成上传。



## Ajax

Asynchronous JavaScript And XML：异步的 Javascript和XML

Ajax 是一种交互方式，异步加载，客户端与服务器的数据交互更新在局部页面的技术，不需要刷新整个页面（局部刷新）。

优点：

1、局部刷新的效率更高。

2、用户的体验更好。

基于 jQuery 的Ajax

~~~ jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/1
  Time: 21:03
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="js/jquery-3.4.1.min.js"></script>
    <script type="text/javascript"> 
        $(function () {
            var btn = $("#btn");
            btn.click(function () {
                $.ajax({
                    url: '/ajaxtest',
                    type:'post',
                    data:'id=1',
                    dataType:'text',
                    success:function (data) {
                        var text = $("#text");
                        text.before("<span>" + data + "</span><br/>")
                    }
                });
            })
        })
    </script>
</head>
<body>
    <input id="text" type="text"><br/>
    <input id="btn" type="button" value="提交">
</body>
</html>

~~~

不能用表单提交请求，改用 jQuery 动态绑定事件来提交。

url：和 form 表单中的 action

type：相当于 form 表单中的 method

data：要传给服务端的属性，如 用户名、密码等，服务端通过 getParameter 方式获取内容。

dataType：是服务端要传送给客户端的数据的类型。

success：data 是 Servlet 返回的数据。

Servlet 不能跳转整个页面，只负责将数据返回。ajax 是将内容添加到页面上，不是对整个页面的刷新。

~~~Java
package com.example.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/ajaxtest")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String str = "Hello World";
        resp.getWriter().write(str);
//        req.setAttribute("str", str);
//        req.getRequestDispatcher("ajaxtest.jsp").forward(req, resp);
    }
}

~~~

### 传统的 WEB 数据交互 和 AJAX 交互的区别

- 客户端请求的方式不同：

传统，浏览器发送 同步请求，通过 form、a

AJAX，异步引擎对象发送异步请求。

- 服务端响应的方式不同：

传统，通过重定向响应一个完整的页面。

AJAX，只需要通过 response 的 write函数 响应需要的数据，不影响页面其他部分。

- 客户端处理方式不同：

传统，需要等待服务器完成响应并且加载整个页面之后，用户才能进行后续的操作

AJAX，只动态更新局部的数据内容，不影响用户在页面其他部分的操作。

### AJAX原理

![image-20200402150030712](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200402150030712.png)

### 基于 jQuery 的 AJAX语法

$.ajax({属性})

常用的属性：

url：请求的的后端服务地址

type：请求的方式，默认为 get

data：请求参数

dataType：服务器返回的数据的类型

success：请求成功的回调函数

error：请求失败的回调函数

complete：无论成功或失败都会回调

### JSON

Javascript Objec Notation ， 一种轻量级数据交互格式，完成 js 与 java 等后端开发语言对象数据之间的转换。

客户端与服务端之间传递对象数据。

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/11
  Time: 15:21
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    编号：<input id="id" type="text"><br>
    姓名：<input id="name" type="text"><br>
    分数：<input id="score" type="text"><br>
    <input id="submit" type="button" value="提交">
<script src="js/jquery-3.3.1.js"></script>
<script>
    $(function () {
        var btn = $("#submit");
        btn.click(function () {
            $.ajax({
                url:"/test",
                type:"post",
                dataType:"json",
                success:function (data) {
                    $("#id").val(data.id);
                    $("#name").val(data.name);
                    $("#score").val(data.score);
                }
            })
        })
    })
</script>
</body>
</html>

~~~



~~~Java
package com.example.servlet;

import com.example.entity.User;
import net.sf.json.JSONObject;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet("/test")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setCharacterEncoding("UTF-8");
        User user = new User(1,"张三", 96.5);
        JSONObject jsonObject = JSONObject.fromObject(user);
        resp.getWriter().write(jsonObject.toString());

    }
}

~~~



将 实体类 转化为 JSON格式所需要的 jar包。

![image-20200411163658514](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200411163658514.png)









## Session

会话




, indexPicture=https://images.unsplash.com/photo-1618762273540-56007afea45e?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80, flag=1, describe=最近学习了一下JVM的内存模型，本来想自己写一篇学习心得，总是觉得自己表达不清，然后就从学习资料里复制一段，写到最后发现，基本都是复制的。, viewCount=null, published=true, recommend=true, createTime=null, updateTime=null, commentList=null, type=Type(id=24, name=null, blogCount=0, blogList=null), writer=null), {blog=Blog(id=1, title=Web学习——过滤器, content=# Web学习

## 过滤器

### Filter

功能：

1、用来拦截传入的请求和传出的响应。

2、修改或以某种方式处理正在客户端和服务端之间交换的数据流。

使用方式：

与使用 Servlet 类似，Filter 是 Java web 提供的一个接口，开发者只需要自定义一个类并实现该接口即可。

``` Java
package com.example.filter;

import javax.servlet.*;
import java.io.IOException;

public class CharacterFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("UTF-8");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}

```

1、Filter 接口有三个函数，另外两个函数有 default 关键字修饰，可实现可不实现。

2、在 doFilter 中，拦截的 request 经过业务处理后通过 filterChain 将处理后的 request 或 response 传递给相应的 servlet，否则，请求/响应就会一直停留在过滤器中。(filterChain.doFilter(servletRequest, servletResponse);)

配置 web.xml

~~~ xml
	<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
        <url-pattern></url-pattern>
    </filter-mapping>
~~~

通过以上方式配置拦截器映射，要是相同拦截方式的界面有多个，可以添加多个 url-pattern。

### Filter生命周期

当 Tomcat 启动时，同过反射机制调用 Filter 的无参构造函数创建实例化对象，同时调用 init 方法完成初始化，一次请求时调用一次 doFilter ，多次请求 ，doFilter 方法就调用多次，当 Tomcat 服务器关闭时，调用 destory 方法销毁 Filter 对象。

无参构造函数：只调用一次，当 Tomcat 启动时调用（Filter 一定要在 web.xml 中配置）

init 函数：只调用一次，当 Filter 实例化对象创建完成之后调用。

doFilter 函数：调用多次，访问 Filter 的业务逻辑都写在 Filter 中。

destory 函数：调用一次，当 Tomcat 关闭时调用。



同时配置多个 Filter 时，Filter 的调用顺序是由 web.xml 中的配置顺序决定的，写在上面的先调用，因为 web.xml 是从上到下读取的。

~~~ xml
<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

    <filter>
        <filter-name>my</filter-name>
        <filter-class>com.example.filter.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>my</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

~~~



也可以通过注解的方式配置 Filter 

~~~ java
@WebFilter("/test")
public class CharacterFilter implements Filter {
    
}
~~~



### Filter 的使用场景

1、解决中文乱码问题。

2、屏蔽敏感词。

​		获取从浏览器传递的信息通过 Parameter 获取，两个资源之间信息的传递通过 Attribute

3、控制资源的访问权限。

~~~ Java
package com.example.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
@WebFilter("/download.jsp")
public class DownloadFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();
        String name = (String)session.getAttribute("name");
        if (name == null) {
            response.sendRedirect("/login.jsp");
        } else {
            filterChain.doFilter(request, response);
        }
    }
}

~~~





## 文件上传和下载

- JSP

1、input 的 type 设置为 file。

2、form 表单的 method 必须设置为 post，如果是 get 只会上传文件名而不是文件。

3、form 表单的 enctype 设置 multipart/form-data，以二进制的形式传输数据。

- Servlet

在实际开发中，使用 fileupload 组件上传文件，属于第三方组件，需要下载 jar 包。可以将所有的请求信息都解析成 Fileitem 对象，通过对 Fileitem 对象的操作完成上传。



## Ajax

Asynchronous JavaScript And XML：异步的 Javascript和XML

Ajax 是一种交互方式，异步加载，客户端与服务器的数据交互更新在局部页面的技术，不需要刷新整个页面（局部刷新）。

优点：

1、局部刷新的效率更高。

2、用户的体验更好。

基于 jQuery 的Ajax

~~~ jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/1
  Time: 21:03
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="js/jquery-3.4.1.min.js"></script>
    <script type="text/javascript"> 
        $(function () {
            var btn = $("#btn");
            btn.click(function () {
                $.ajax({
                    url: '/ajaxtest',
                    type:'post',
                    data:'id=1',
                    dataType:'text',
                    success:function (data) {
                        var text = $("#text");
                        text.before("<span>" + data + "</span><br/>")
                    }
                });
            })
        })
    </script>
</head>
<body>
    <input id="text" type="text"><br/>
    <input id="btn" type="button" value="提交">
</body>
</html>

~~~

不能用表单提交请求，改用 jQuery 动态绑定事件来提交。

url：和 form 表单中的 action

type：相当于 form 表单中的 method

data：要传给服务端的属性，如 用户名、密码等，服务端通过 getParameter 方式获取内容。

dataType：是服务端要传送给客户端的数据的类型。

success：data 是 Servlet 返回的数据。

Servlet 不能跳转整个页面，只负责将数据返回。ajax 是将内容添加到页面上，不是对整个页面的刷新。

~~~Java
package com.example.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/ajaxtest")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String str = "Hello World";
        resp.getWriter().write(str);
//        req.setAttribute("str", str);
//        req.getRequestDispatcher("ajaxtest.jsp").forward(req, resp);
    }
}

~~~

### 传统的 WEB 数据交互 和 AJAX 交互的区别

- 客户端请求的方式不同：

传统，浏览器发送 同步请求，通过 form、a

AJAX，异步引擎对象发送异步请求。

- 服务端响应的方式不同：

传统，通过重定向响应一个完整的页面。

AJAX，只需要通过 response 的 write函数 响应需要的数据，不影响页面其他部分。

- 客户端处理方式不同：

传统，需要等待服务器完成响应并且加载整个页面之后，用户才能进行后续的操作

AJAX，只动态更新局部的数据内容，不影响用户在页面其他部分的操作。

### AJAX原理

![image-20200402150030712](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200402150030712.png)

### 基于 jQuery 的 AJAX语法

$.ajax({属性})

常用的属性：

url：请求的的后端服务地址

type：请求的方式，默认为 get

data：请求参数

dataType：服务器返回的数据的类型

success：请求成功的回调函数

error：请求失败的回调函数

complete：无论成功或失败都会回调

### JSON

Javascript Objec Notation ， 一种轻量级数据交互格式，完成 js 与 java 等后端开发语言对象数据之间的转换。

客户端与服务端之间传递对象数据。

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/11
  Time: 15:21
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    编号：<input id="id" type="text"><br>
    姓名：<input id="name" type="text"><br>
    分数：<input id="score" type="text"><br>
    <input id="submit" type="button" value="提交">
<script src="js/jquery-3.3.1.js"></script>
<script>
    $(function () {
        var btn = $("#submit");
        btn.click(function () {
            $.ajax({
                url:"/test",
                type:"post",
                dataType:"json",
                success:function (data) {
                    $("#id").val(data.id);
                    $("#name").val(data.name);
                    $("#score").val(data.score);
                }
            })
        })
    })
</script>
</body>
</html>

~~~



~~~Java
package com.example.servlet;

import com.example.entity.User;
import net.sf.json.JSONObject;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet("/test")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setCharacterEncoding("UTF-8");
        User user = new User(1,"张三", 96.5);
        JSONObject jsonObject = JSONObject.fromObject(user);
        resp.getWriter().write(jsonObject.toString());

    }
}

~~~



将 实体类 转化为 JSON格式所需要的 jar包。

![image-20200411163658514](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200411163658514.png)









## Session

会话




, indexPicture=https://images.unsplash.com/photo-1618762273540-56007afea45e?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80, flag=1, describe=最近学习了一下JVM的内存模型，本来想自己写一篇学习心得，总是觉得自己表达不清，然后就从学习资料里复制一段，写到最后发现，基本都是复制的。, viewCount=null, published=true, recommend=true, createTime=null, updateTime=null, commentList=null, type=Type(id=24, name=null, blogCount=0, blogList=null), writer=null), org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, {}])
2021-05-04 11:05:01.580  INFO 15436 --- [http-nio-8080-exec-3] com.program.blog.aspect.LogAspect        : Result : redirect:/admin/blogs
2021-05-04 11:05:01.621  INFO 15436 --- [http-nio-8080-exec-1] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogsPage, args=[{message=success}, 1])
2021-05-04 11:05:01.633  INFO 15436 --- [http-nio-8080-exec-1] com.program.blog.aspect.LogAspect        : Result : admin/blogs
2021-05-04 11:05:06.141  INFO 15436 --- [http-nio-8080-exec-4] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs/1/edit, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogEditPage, args=[1, {}])
2021-05-04 11:05:06.154  INFO 15436 --- [http-nio-8080-exec-4] com.program.blog.aspect.LogAspect        : Result : /admin/blogs-input
2021-05-04 11:05:11.374  INFO 15436 --- [http-nio-8080-exec-5] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs/1/edit, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogEdit, args=[1, Blog(id=1, title=Web学习——过滤器, content=# Web学习

## 过滤器

### Filter

功能：

1、用来拦截传入的请求和传出的响应。

2、修改或以某种方式处理正在客户端和服务端之间交换的数据流。

使用方式：

与使用 Servlet 类似，Filter 是 Java web 提供的一个接口，开发者只需要自定义一个类并实现该接口即可。

``` Java
package com.example.filter;

import javax.servlet.*;
import java.io.IOException;

public class CharacterFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("UTF-8");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}

```

1、Filter 接口有三个函数，另外两个函数有 default 关键字修饰，可实现可不实现。

2、在 doFilter 中，拦截的 request 经过业务处理后通过 filterChain 将处理后的 request 或 response 传递给相应的 servlet，否则，请求/响应就会一直停留在过滤器中。(filterChain.doFilter(servletRequest, servletResponse);)

配置 web.xml

~~~ xml
	<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
        <url-pattern></url-pattern>
    </filter-mapping>
~~~

通过以上方式配置拦截器映射，要是相同拦截方式的界面有多个，可以添加多个 url-pattern。

### Filter生命周期

当 Tomcat 启动时，同过反射机制调用 Filter 的无参构造函数创建实例化对象，同时调用 init 方法完成初始化，一次请求时调用一次 doFilter ，多次请求 ，doFilter 方法就调用多次，当 Tomcat 服务器关闭时，调用 destory 方法销毁 Filter 对象。

无参构造函数：只调用一次，当 Tomcat 启动时调用（Filter 一定要在 web.xml 中配置）

init 函数：只调用一次，当 Filter 实例化对象创建完成之后调用。

doFilter 函数：调用多次，访问 Filter 的业务逻辑都写在 Filter 中。

destory 函数：调用一次，当 Tomcat 关闭时调用。



同时配置多个 Filter 时，Filter 的调用顺序是由 web.xml 中的配置顺序决定的，写在上面的先调用，因为 web.xml 是从上到下读取的。

~~~ xml
<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

    <filter>
        <filter-name>my</filter-name>
        <filter-class>com.example.filter.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>my</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

~~~



也可以通过注解的方式配置 Filter 

~~~ java
@WebFilter("/test")
public class CharacterFilter implements Filter {
    
}
~~~



### Filter 的使用场景

1、解决中文乱码问题。

2、屏蔽敏感词。

​		获取从浏览器传递的信息通过 Parameter 获取，两个资源之间信息的传递通过 Attribute

3、控制资源的访问权限。

~~~ Java
package com.example.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
@WebFilter("/download.jsp")
public class DownloadFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();
        String name = (String)session.getAttribute("name");
        if (name == null) {
            response.sendRedirect("/login.jsp");
        } else {
            filterChain.doFilter(request, response);
        }
    }
}

~~~





## 文件上传和下载

- JSP

1、input 的 type 设置为 file。

2、form 表单的 method 必须设置为 post，如果是 get 只会上传文件名而不是文件。

3、form 表单的 enctype 设置 multipart/form-data，以二进制的形式传输数据。

- Servlet

在实际开发中，使用 fileupload 组件上传文件，属于第三方组件，需要下载 jar 包。可以将所有的请求信息都解析成 Fileitem 对象，通过对 Fileitem 对象的操作完成上传。



## Ajax

Asynchronous JavaScript And XML：异步的 Javascript和XML

Ajax 是一种交互方式，异步加载，客户端与服务器的数据交互更新在局部页面的技术，不需要刷新整个页面（局部刷新）。

优点：

1、局部刷新的效率更高。

2、用户的体验更好。

基于 jQuery 的Ajax

~~~ jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/1
  Time: 21:03
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="js/jquery-3.4.1.min.js"></script>
    <script type="text/javascript"> 
        $(function () {
            var btn = $("#btn");
            btn.click(function () {
                $.ajax({
                    url: '/ajaxtest',
                    type:'post',
                    data:'id=1',
                    dataType:'text',
                    success:function (data) {
                        var text = $("#text");
                        text.before("<span>" + data + "</span><br/>")
                    }
                });
            })
        })
    </script>
</head>
<body>
    <input id="text" type="text"><br/>
    <input id="btn" type="button" value="提交">
</body>
</html>

~~~

不能用表单提交请求，改用 jQuery 动态绑定事件来提交。

url：和 form 表单中的 action

type：相当于 form 表单中的 method

data：要传给服务端的属性，如 用户名、密码等，服务端通过 getParameter 方式获取内容。

dataType：是服务端要传送给客户端的数据的类型。

success：data 是 Servlet 返回的数据。

Servlet 不能跳转整个页面，只负责将数据返回。ajax 是将内容添加到页面上，不是对整个页面的刷新。

~~~Java
package com.example.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/ajaxtest")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String str = "Hello World";
        resp.getWriter().write(str);
//        req.setAttribute("str", str);
//        req.getRequestDispatcher("ajaxtest.jsp").forward(req, resp);
    }
}

~~~

### 传统的 WEB 数据交互 和 AJAX 交互的区别

- 客户端请求的方式不同：

传统，浏览器发送 同步请求，通过 form、a

AJAX，异步引擎对象发送异步请求。

- 服务端响应的方式不同：

传统，通过重定向响应一个完整的页面。

AJAX，只需要通过 response 的 write函数 响应需要的数据，不影响页面其他部分。

- 客户端处理方式不同：

传统，需要等待服务器完成响应并且加载整个页面之后，用户才能进行后续的操作

AJAX，只动态更新局部的数据内容，不影响用户在页面其他部分的操作。

### AJAX原理

![image-20200402150030712](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200402150030712.png)

### 基于 jQuery 的 AJAX语法

$.ajax({属性})

常用的属性：

url：请求的的后端服务地址

type：请求的方式，默认为 get

data：请求参数

dataType：服务器返回的数据的类型

success：请求成功的回调函数

error：请求失败的回调函数

complete：无论成功或失败都会回调

### JSON

Javascript Objec Notation ， 一种轻量级数据交互格式，完成 js 与 java 等后端开发语言对象数据之间的转换。

客户端与服务端之间传递对象数据。

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/11
  Time: 15:21
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    编号：<input id="id" type="text"><br>
    姓名：<input id="name" type="text"><br>
    分数：<input id="score" type="text"><br>
    <input id="submit" type="button" value="提交">
<script src="js/jquery-3.3.1.js"></script>
<script>
    $(function () {
        var btn = $("#submit");
        btn.click(function () {
            $.ajax({
                url:"/test",
                type:"post",
                dataType:"json",
                success:function (data) {
                    $("#id").val(data.id);
                    $("#name").val(data.name);
                    $("#score").val(data.score);
                }
            })
        })
    })
</script>
</body>
</html>

~~~



~~~Java
package com.example.servlet;

import com.example.entity.User;
import net.sf.json.JSONObject;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet("/test")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setCharacterEncoding("UTF-8");
        User user = new User(1,"张三", 96.5);
        JSONObject jsonObject = JSONObject.fromObject(user);
        resp.getWriter().write(jsonObject.toString());

    }
}

~~~



将 实体类 转化为 JSON格式所需要的 jar包。

![image-20200411163658514](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200411163658514.png)









## Session

会话




, indexPicture=https://images.unsplash.com/photo-1618762273540-56007afea45e?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80, flag=1, describe=最近学习了一下JVM的内存模型，本来想自己写一篇学习心得，总是觉得自己表达不清，然后就从学习资料里复制一段，写到最后发现，基本都是复制的。, viewCount=null, published=true, recommend=true, createTime=null, updateTime=null, commentList=null, type=Type(id=24, name=null, blogCount=0, blogList=null), writer=null), {blog=Blog(id=1, title=Web学习——过滤器, content=# Web学习

## 过滤器

### Filter

功能：

1、用来拦截传入的请求和传出的响应。

2、修改或以某种方式处理正在客户端和服务端之间交换的数据流。

使用方式：

与使用 Servlet 类似，Filter 是 Java web 提供的一个接口，开发者只需要自定义一个类并实现该接口即可。

``` Java
package com.example.filter;

import javax.servlet.*;
import java.io.IOException;

public class CharacterFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("UTF-8");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}

```

1、Filter 接口有三个函数，另外两个函数有 default 关键字修饰，可实现可不实现。

2、在 doFilter 中，拦截的 request 经过业务处理后通过 filterChain 将处理后的 request 或 response 传递给相应的 servlet，否则，请求/响应就会一直停留在过滤器中。(filterChain.doFilter(servletRequest, servletResponse);)

配置 web.xml

~~~ xml
	<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
        <url-pattern></url-pattern>
    </filter-mapping>
~~~

通过以上方式配置拦截器映射，要是相同拦截方式的界面有多个，可以添加多个 url-pattern。

### Filter生命周期

当 Tomcat 启动时，同过反射机制调用 Filter 的无参构造函数创建实例化对象，同时调用 init 方法完成初始化，一次请求时调用一次 doFilter ，多次请求 ，doFilter 方法就调用多次，当 Tomcat 服务器关闭时，调用 destory 方法销毁 Filter 对象。

无参构造函数：只调用一次，当 Tomcat 启动时调用（Filter 一定要在 web.xml 中配置）

init 函数：只调用一次，当 Filter 实例化对象创建完成之后调用。

doFilter 函数：调用多次，访问 Filter 的业务逻辑都写在 Filter 中。

destory 函数：调用一次，当 Tomcat 关闭时调用。



同时配置多个 Filter 时，Filter 的调用顺序是由 web.xml 中的配置顺序决定的，写在上面的先调用，因为 web.xml 是从上到下读取的。

~~~ xml
<filter>
        <filter-name>character</filter-name>
        <filter-class>com.example.filter.CharacterFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>character</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

    <filter>
        <filter-name>my</filter-name>
        <filter-class>com.example.filter.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>my</filter-name>
        <url-pattern>/test</url-pattern>
    </filter-mapping>

~~~



也可以通过注解的方式配置 Filter 

~~~ java
@WebFilter("/test")
public class CharacterFilter implements Filter {
    
}
~~~



### Filter 的使用场景

1、解决中文乱码问题。

2、屏蔽敏感词。

​		获取从浏览器传递的信息通过 Parameter 获取，两个资源之间信息的传递通过 Attribute

3、控制资源的访问权限。

~~~ Java
package com.example.filter;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import java.io.IOException;
@WebFilter("/download.jsp")
public class DownloadFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        HttpSession session = request.getSession();
        String name = (String)session.getAttribute("name");
        if (name == null) {
            response.sendRedirect("/login.jsp");
        } else {
            filterChain.doFilter(request, response);
        }
    }
}

~~~





## 文件上传和下载

- JSP

1、input 的 type 设置为 file。

2、form 表单的 method 必须设置为 post，如果是 get 只会上传文件名而不是文件。

3、form 表单的 enctype 设置 multipart/form-data，以二进制的形式传输数据。

- Servlet

在实际开发中，使用 fileupload 组件上传文件，属于第三方组件，需要下载 jar 包。可以将所有的请求信息都解析成 Fileitem 对象，通过对 Fileitem 对象的操作完成上传。



## Ajax

Asynchronous JavaScript And XML：异步的 Javascript和XML

Ajax 是一种交互方式，异步加载，客户端与服务器的数据交互更新在局部页面的技术，不需要刷新整个页面（局部刷新）。

优点：

1、局部刷新的效率更高。

2、用户的体验更好。

基于 jQuery 的Ajax

~~~ jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/1
  Time: 21:03
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="js/jquery-3.4.1.min.js"></script>
    <script type="text/javascript"> 
        $(function () {
            var btn = $("#btn");
            btn.click(function () {
                $.ajax({
                    url: '/ajaxtest',
                    type:'post',
                    data:'id=1',
                    dataType:'text',
                    success:function (data) {
                        var text = $("#text");
                        text.before("<span>" + data + "</span><br/>")
                    }
                });
            })
        })
    </script>
</head>
<body>
    <input id="text" type="text"><br/>
    <input id="btn" type="button" value="提交">
</body>
</html>

~~~

不能用表单提交请求，改用 jQuery 动态绑定事件来提交。

url：和 form 表单中的 action

type：相当于 form 表单中的 method

data：要传给服务端的属性，如 用户名、密码等，服务端通过 getParameter 方式获取内容。

dataType：是服务端要传送给客户端的数据的类型。

success：data 是 Servlet 返回的数据。

Servlet 不能跳转整个页面，只负责将数据返回。ajax 是将内容添加到页面上，不是对整个页面的刷新。

~~~Java
package com.example.servlet;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet("/ajaxtest")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        String str = "Hello World";
        resp.getWriter().write(str);
//        req.setAttribute("str", str);
//        req.getRequestDispatcher("ajaxtest.jsp").forward(req, resp);
    }
}

~~~

### 传统的 WEB 数据交互 和 AJAX 交互的区别

- 客户端请求的方式不同：

传统，浏览器发送 同步请求，通过 form、a

AJAX，异步引擎对象发送异步请求。

- 服务端响应的方式不同：

传统，通过重定向响应一个完整的页面。

AJAX，只需要通过 response 的 write函数 响应需要的数据，不影响页面其他部分。

- 客户端处理方式不同：

传统，需要等待服务器完成响应并且加载整个页面之后，用户才能进行后续的操作

AJAX，只动态更新局部的数据内容，不影响用户在页面其他部分的操作。

### AJAX原理

![image-20200402150030712](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200402150030712.png)

### 基于 jQuery 的 AJAX语法

$.ajax({属性})

常用的属性：

url：请求的的后端服务地址

type：请求的方式，默认为 get

data：请求参数

dataType：服务器返回的数据的类型

success：请求成功的回调函数

error：请求失败的回调函数

complete：无论成功或失败都会回调

### JSON

Javascript Objec Notation ， 一种轻量级数据交互格式，完成 js 与 java 等后端开发语言对象数据之间的转换。

客户端与服务端之间传递对象数据。

~~~jsp
<%--
  Created by IntelliJ IDEA.
  User: 啦啦啦
  Date: 2020/4/11
  Time: 15:21
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    编号：<input id="id" type="text"><br>
    姓名：<input id="name" type="text"><br>
    分数：<input id="score" type="text"><br>
    <input id="submit" type="button" value="提交">
<script src="js/jquery-3.3.1.js"></script>
<script>
    $(function () {
        var btn = $("#submit");
        btn.click(function () {
            $.ajax({
                url:"/test",
                type:"post",
                dataType:"json",
                success:function (data) {
                    $("#id").val(data.id);
                    $("#name").val(data.name);
                    $("#score").val(data.score);
                }
            })
        })
    })
</script>
</body>
</html>

~~~



~~~Java
package com.example.servlet;

import com.example.entity.User;
import net.sf.json.JSONObject;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
@WebServlet("/test")
public class AjaxTest extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setCharacterEncoding("UTF-8");
        User user = new User(1,"张三", 96.5);
        JSONObject jsonObject = JSONObject.fromObject(user);
        resp.getWriter().write(jsonObject.toString());

    }
}

~~~



将 实体类 转化为 JSON格式所需要的 jar包。

![image-20200411163658514](C:\Users\啦啦啦\AppData\Roaming\Typora\typora-user-images\image-20200411163658514.png)









## Session

会话




, indexPicture=https://images.unsplash.com/photo-1618762273540-56007afea45e?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80, flag=1, describe=最近学习了一下JVM的内存模型，本来想自己写一篇学习心得，总是觉得自己表达不清，然后就从学习资料里复制一段，写到最后发现，基本都是复制的。, viewCount=null, published=true, recommend=true, createTime=null, updateTime=null, commentList=null, type=Type(id=24, name=null, blogCount=0, blogList=null), writer=null), org.springframework.validation.BindingResult.blog=org.springframework.validation.BeanPropertyBindingResult: 0 errors}, {}])
2021-05-04 11:05:11.403  INFO 15436 --- [http-nio-8080-exec-5] com.program.blog.aspect.LogAspect        : Result : redirect:/admin/blogs
2021-05-04 11:05:11.409  INFO 15436 --- [http-nio-8080-exec-8] com.program.blog.aspect.LogAspect        : Request: LogAspect.RequestLog(url=http://localhost:8080/admin/blogs, ip=0:0:0:0:0:0:0:1, classMethod=com.program.blog.controller.admin.BlogController.blogsPage, args=[{message=success}, 1])
2021-05-04 11:05:11.421  INFO 15436 --- [http-nio-8080-exec-8] com.program.blog.aspect.LogAspect        : Result : admin/blogs
2021-05-04 11:07:23.114  INFO 15436 --- [Thread-5] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-05-04 11:07:23.116  INFO 15436 --- [Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2021-05-04 11:07:23.168  INFO 15436 --- [Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2021-05-04 11:07:23.293  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : Starting BlogApplication using Java 12.0.2 on LAPTOP-B2BM54RN with PID 15436 (E:\IdeaProjects\blog\target\classes started by 轩 in E:\IdeaProjects\blog)
2021-05-04 11:07:23.293 DEBUG 15436 --- [restartedMain] com.program.blog.BlogApplication         : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:07:23.293  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : The following profiles are active: dev
2021-05-04 11:07:23.695  INFO 15436 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-05-04 11:07:23.696  INFO 15436 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-05-04 11:07:23.696  INFO 15436 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-05-04 11:07:23.739  INFO 15436 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-05-04 11:07:23.739  INFO 15436 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 443 ms
2021-05-04 11:07:24.175  INFO 15436 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:07:24.245  INFO 15436 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:07:24.561  INFO 15436 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-05-04 11:07:24.599  INFO 15436 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-05-04 11:07:24.606  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : Started BlogApplication in 1.359 seconds (JVM running for 495.383)
2021-05-04 11:07:24.608  INFO 15436 --- [restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged
2021-05-04 11:07:27.176  INFO 15992 --- [main] com.program.blog.BlogApplicationTests    : Starting BlogApplicationTests using Java 12.0.2 on LAPTOP-B2BM54RN with PID 15992 (started by  in E:\IdeaProjects\blog)
2021-05-04 11:07:27.178 DEBUG 15992 --- [main] com.program.blog.BlogApplicationTests    : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:07:27.179  INFO 15992 --- [main] com.program.blog.BlogApplicationTests    : The following profiles are active: dev
2021-05-04 11:07:30.555  INFO 15992 --- [main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:07:30.805  INFO 15992 --- [main] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:07:31.590  INFO 15992 --- [main] com.program.blog.BlogApplicationTests    : Started BlogApplicationTests in 5.018 seconds (JVM running for 6.46)
2021-05-04 11:07:32.562  INFO 15992 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-05-04 11:10:30.444  INFO 15436 --- [Thread-8] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-05-04 11:10:30.562  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : Starting BlogApplication using Java 12.0.2 on LAPTOP-B2BM54RN with PID 15436 (E:\IdeaProjects\blog\target\classes started by 轩 in E:\IdeaProjects\blog)
2021-05-04 11:10:30.562 DEBUG 15436 --- [restartedMain] com.program.blog.BlogApplication         : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:10:30.562  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : The following profiles are active: pro
2021-05-04 11:10:30.962  INFO 15436 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-05-04 11:10:30.963  INFO 15436 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-05-04 11:10:30.964  INFO 15436 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-05-04 11:10:31.015  INFO 15436 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-05-04 11:10:31.015  INFO 15436 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 449 ms
2021-05-04 11:10:31.438  INFO 15436 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:10:31.500  INFO 15436 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:10:31.793  INFO 15436 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-05-04 11:10:31.815  INFO 15436 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-05-04 11:10:31.822  INFO 15436 --- [restartedMain] com.program.blog.BlogApplication         : Started BlogApplication in 1.315 seconds (JVM running for 682.599)
2021-05-04 11:10:31.824  INFO 15436 --- [restartedMain] .ConditionEvaluationDeltaLoggingListener : Condition evaluation unchanged
2021-05-04 11:10:31.851  INFO 6472 --- [main] com.program.blog.BlogApplicationTests    : Starting BlogApplicationTests using Java 12.0.2 on LAPTOP-B2BM54RN with PID 6472 (started by  in E:\IdeaProjects\blog)
2021-05-04 11:10:31.854 DEBUG 6472 --- [main] com.program.blog.BlogApplicationTests    : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:10:31.854  INFO 6472 --- [main] com.program.blog.BlogApplicationTests    : The following profiles are active: pro
2021-05-04 11:10:35.069  INFO 6472 --- [main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:10:35.321  INFO 6472 --- [main] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:10:36.381  INFO 6472 --- [main] com.program.blog.BlogApplicationTests    : Started BlogApplicationTests in 5.161 seconds (JVM running for 6.542)
2021-05-04 11:10:37.190  INFO 6472 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-05-04 11:14:12.948  INFO 9212 --- [main] com.program.blog.BlogApplicationTests    : Starting BlogApplicationTests using Java 12.0.2 on LAPTOP-B2BM54RN with PID 9212 (started by  in E:\IdeaProjects\blog)
2021-05-04 11:14:12.950 DEBUG 9212 --- [main] com.program.blog.BlogApplicationTests    : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:14:12.950  INFO 9212 --- [main] com.program.blog.BlogApplicationTests    : The following profiles are active: pro
2021-05-04 11:14:16.368  INFO 9212 --- [main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:14:16.629  INFO 9212 --- [main] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:14:17.468  INFO 9212 --- [main] com.program.blog.BlogApplicationTests    : Started BlogApplicationTests in 5.126 seconds (JVM running for 6.445)
2021-05-04 11:14:18.142  INFO 9212 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
2021-05-04 11:23:19.171  INFO 1640 --- [restartedMain] com.program.blog.BlogApplication         : Starting BlogApplication using Java 12.0.2 on LAPTOP-B2BM54RN with PID 1640 (E:\IdeaProjects\blog\target\classes started by 轩 in E:\IdeaProjects\blog)
2021-05-04 11:23:19.176 DEBUG 1640 --- [restartedMain] com.program.blog.BlogApplication         : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:23:19.177  INFO 1640 --- [restartedMain] com.program.blog.BlogApplication         : The following profiles are active: dev
2021-05-04 11:23:19.237  INFO 1640 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable
2021-05-04 11:23:19.237  INFO 1640 --- [restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'
2021-05-04 11:23:20.709  INFO 1640 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
2021-05-04 11:23:20.718  INFO 1640 --- [restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2021-05-04 11:23:20.719  INFO 1640 --- [restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.41]
2021-05-04 11:23:20.819  INFO 1640 --- [restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2021-05-04 11:23:20.819  INFO 1640 --- [restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1580 ms
2021-05-04 11:23:21.616  INFO 1640 --- [restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:23:21.751  INFO 1640 --- [restartedMain] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:23:22.312  INFO 1640 --- [restartedMain] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729
2021-05-04 11:23:22.354  INFO 1640 --- [restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2021-05-04 11:23:22.369  INFO 1640 --- [restartedMain] com.program.blog.BlogApplication         : Started BlogApplication in 3.749 seconds (JVM running for 5.358)
2021-05-04 11:23:33.743  INFO 5832 --- [main] com.program.blog.BlogApplicationTests    : Starting BlogApplicationTests using Java 12.0.2 on LAPTOP-B2BM54RN with PID 5832 (started by  in E:\IdeaProjects\blog)
2021-05-04 11:23:33.746 DEBUG 5832 --- [main] com.program.blog.BlogApplicationTests    : Running with Spring Boot v2.4.2, Spring v5.3.3
2021-05-04 11:23:33.747  INFO 5832 --- [main] com.program.blog.BlogApplicationTests    : The following profiles are active: dev
2021-05-04 11:23:37.193  INFO 5832 --- [main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
2021-05-04 11:23:37.408  INFO 5832 --- [main] o.s.b.a.w.s.WelcomePageHandlerMapping    : Adding welcome page template: index
2021-05-04 11:23:38.198  INFO 5832 --- [main] com.program.blog.BlogApplicationTests    : Started BlogApplicationTests in 5.06 seconds (JVM running for 6.455)
2021-05-04 11:23:38.906  INFO 5832 --- [SpringContextShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
